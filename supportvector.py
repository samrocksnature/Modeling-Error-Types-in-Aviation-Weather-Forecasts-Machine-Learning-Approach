# -*- coding: utf-8 -*-
"""SupportVector

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YPlGTMAJygpTZE9HgWJ1Q8tuee_lGVmB
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import confusion_matrix  # Import confusion_matrix

# Load the data
data = pd.read_csv('/content/merged_metar_taf.csv')

# Define features and target variables
features = ['Ceiling_TAF (ft)', 'Visibility_TAF (km)', 'Altitude (ft)', 'Latitude (degrees)', 'Longitude (degrees)', 'Distance (km)',
            'Koppen Climate Classification']
target = 'Error_type'

# Fix non-numeric issues
data['Visibility_METAR (km)'] = data['Visibility_METAR (km)'].replace({'10+': 10, '6+': 6}, regex=True).astype(float)
data['Visibility_TAF (km)'] = data['Visibility_TAF (km)'].replace({'6+': 6}, regex=True).astype(float)
data['Longitude (degrees)'] = data['Longitude (degrees)'].str.extract(r'([-0-9.]+)').astype(float)
data['Weather_TAF'] = data['Weather_TAF'].astype('category').cat.codes
data['Koppen Climate Classification'] = data['Koppen Climate Classification'].astype('category').cat.codes
error_mapping = {
    'Correct - No error (0)': 0,
    'Fail to Detect - Type II (2) error': 2,
    'False Alarm - Type I (1) error': 1
}
data['Error_type'] = data['Error_type'].map(error_mapping)
data[features + [target]] = data[features + [target]].apply(pd.to_numeric, errors='coerce')

# Ensure the dataset is not empty
data = data.dropna()
if data.empty:
    raise ValueError("The dataset is empty after filtering. Please check the input data.")

# Scaling features to [0,1]
scaler = MinMaxScaler()
scaled_features = scaler.fit_transform(data[features])
X = scaled_features
y = data[target].values

# Splitting the dataset into 80% training and 20% testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=457752)

# Function to train and evaluate SVM with different kernels
def evaluate_svm(kernel):
    # Fitting SVM Classifier
    svmc = SVC(kernel=kernel).fit(X_train, y_train)

    # Predicting on the test data
    y_pred = svmc.predict(X_test)

    # Creating DataFrames for better comparison (optional)
    y_test_df = pd.DataFrame(y_test, columns=['actual'])
    y_pred_df = pd.DataFrame(y_pred, columns=['predicted'])
    results_df = pd.concat([y_test_df, y_pred_df], axis=1)

    # Compute accuracy
    match = results_df['actual'] == results_df['predicted']
    accuracy = match.mean() * 100
    print(f'\n{kernel.capitalize()} Kernel')
    print(f'Accuracy: {round(accuracy, 2)}%')

    # Compute and print confusion matrix
    cm = confusion_matrix(y_test, y_pred)
    print("Confusion Matrix:")
    print(cm)

# Evaluate SVM with different kernels
evaluate_svm('linear')
evaluate_svm('poly')
evaluate_svm('rbf')
evaluate_svm('sigmoid')